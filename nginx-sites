#!/usr/bin/env python3
"""
Nginx Sites Configuration Manager

Manages nginx site configurations through a centralized YAML file.
"""

import click
import yaml
import logging
import sys
from pathlib import Path
from typing import Optional

from lib.config_parser import ConfigParser
from lib.generator import NginxGenerator
from lib.migrator import NginxMigrator
from lib.certbot_manager import CertbotManager
from lib.backup import BackupManager
from lib.validator import NginxValidator
from lib.permissions import require_sudo_privileges, validate_all_permissions, InsufficientPermissionsError
from lib.route53_manager import Route53Manager

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Paths
BASE_DIR = Path(__file__).parent.absolute()
CONFIG_FILE = BASE_DIR / 'sites-config.yaml'
TEMPLATE_DIR = BASE_DIR / 'templates'
BACKUP_DIR = BASE_DIR / 'backups'
SITES_AVAILABLE = Path('/etc/nginx/sites-available')
SITES_ENABLED = Path('/etc/nginx/sites-enabled')


def _clean_existing_sites():
    """
    Clean existing nginx sites before regeneration.
    Removes all sites-available files except 'default' and all sites-enabled symlinks.
    """
    import os
    
    # Remove all sites-available files except 'default'
    if SITES_AVAILABLE.exists():
        removed_count = 0
        for site_file in SITES_AVAILABLE.iterdir():
            if site_file.is_file() and site_file.name.lower() != 'default':
                try:
                    site_file.unlink()
                    removed_count += 1
                except OSError as e:
                    logger.warning(f"Failed to remove {site_file}: {e}")
        
        if removed_count > 0:
            click.echo(f"Removed {removed_count} existing site configuration(s)")
    
    # Remove all sites-enabled symlinks
    if SITES_ENABLED.exists():
        removed_symlinks = 0
        for symlink in SITES_ENABLED.iterdir():
            if symlink.is_symlink() or symlink.is_file():
                try:
                    symlink.unlink()
                    removed_symlinks += 1
                except OSError as e:
                    logger.warning(f"Failed to remove symlink {symlink}: {e}")
        
        if removed_symlinks > 0:
            click.echo(f"Removed {removed_symlinks} existing site symlink(s)")
    else:
        # Create sites-enabled directory if it doesn't exist
        SITES_ENABLED.mkdir(exist_ok=True)
        logger.info("Created sites-enabled directory")


@click.group()
@click.option('--verbose', '-v', is_flag=True, help='Enable verbose output')
@click.option('--config', '-c', type=click.Path(exists=True), help='Path to configuration file')
@click.pass_context
def cli(ctx, verbose, config):
    """Nginx Sites Configuration Manager"""
    # Ensure context object exists
    ctx.ensure_object(dict)
    
    # Setup logging level
    if verbose:
        logging.getLogger().setLevel(logging.DEBUG)
        logger.debug("Verbose logging enabled")
    
    # Set configuration file path
    if config:
        ctx.obj['config_file'] = Path(config)
        logger.debug(f"Using configuration file: {config}")
    else:
        ctx.obj['config_file'] = CONFIG_FILE
        logger.debug(f"Using default configuration file: {CONFIG_FILE}")


@cli.command()
@click.option('--dry-run', is_flag=True, help='Show what would be done without making changes')
@click.option('--no-backup', is_flag=True, help='Skip creating backup')
@click.option('--force', is_flag=True, help='Skip validation and force generation')
@click.option('--sync-dns', is_flag=True, help='Sync DNS records after generation')
@click.option('--aws-profile', default='route53', help='AWS profile to use for Route 53')
@click.pass_context
def generate(ctx, dry_run: bool, no_backup: bool, force: bool, sync_dns: bool, aws_profile: str):
    """Generate nginx configurations from YAML"""
    config_file = ctx.obj['config_file']
    
    # Check permissions first (unless dry-run)
    if not dry_run:
        try:
            require_sudo_privileges()
        except SystemExit:
            return
    
    if not config_file.exists():
        click.echo(f"Error: Configuration file not found: {config_file}")
        click.echo("Run 'nginx-sites migrate' to create an initial configuration")
        sys.exit(1)
    
    try:
        # Parse configuration
        parser = ConfigParser(config_file)
        
        # Validate configuration unless forced
        if not force:
            errors = parser.validate_config()
            if errors:
                click.echo("Configuration validation errors:")
                for error in errors:
                    click.echo(f"  - {error}")
                click.echo("\nUse --force to ignore validation errors")
                sys.exit(1)
        
        # Initialize generator
        generator = NginxGenerator(TEMPLATE_DIR)
        
        # Create backup unless skipped or dry-run
        if not no_backup and not dry_run:
            backup_manager = BackupManager(BACKUP_DIR)
            backup_path = backup_manager.create_backup("pre_generate")
            click.echo(f"Created backup: {backup_path.name}")
        
        # Get enabled sites
        enabled_sites = parser.get_enabled_sites()
        
        if not enabled_sites:
            click.echo("No enabled sites found in configuration")
            return
        
        # Clean existing sites before regeneration (unless dry-run)
        if not dry_run:
            _clean_existing_sites()
        
        # Generate configurations
        click.echo(f"Generating configurations for {len(enabled_sites)} sites...")
        
        generated = {}
        for domain, config in enabled_sites.items():
            try:
                nginx_config = generator.generate_site(domain, config)
                generated[domain] = nginx_config
                
                if dry_run:
                    click.echo(f"\n{'='*60}")
                    click.echo(f"Configuration for {domain}:")
                    click.echo('='*60)
                    click.echo(nginx_config)
                else:
                    # Write to sites-available
                    site_file = SITES_AVAILABLE / domain
                    site_file.write_text(nginx_config)
                    click.echo(f"Generated: {domain}")
                    
                    # Enable site (create symlink)
                    enabled_link = SITES_ENABLED / domain
                    enabled_link.symlink_to(f"../sites-available/{domain}")
                    click.echo(f"Enabled: {domain}")
                        
            except Exception as e:
                click.echo(f"Error generating {domain}: {e}")
                logger.exception(f"Failed to generate {domain}")
        
        if dry_run:
            click.echo(f"\nDry run complete. {len(generated)} configurations would be generated.")
        else:
            # Validate nginx configuration
            validator = NginxValidator()
            valid, message = validator.validate_config()
            
            if valid:
                click.echo(f"Successfully generated {len(generated)} configurations")
                
                # Reload nginx
                success, reload_msg = validator.reload_nginx()
                if success:
                    click.echo("Nginx reloaded successfully")
                else:
                    click.echo(f"Warning: Failed to reload nginx: {reload_msg}")
                
                # Sync DNS records if requested
                if sync_dns:
                    try:
                        route53 = Route53Manager(profile_name=aws_profile)
                        enabled_domains = list(enabled_sites.keys())
                        created, deleted = route53.sync_dns_records(enabled_domains)
                        click.echo(f"DNS sync complete: {created} created, {deleted} deleted")
                    except Exception as e:
                        click.echo(f"Warning: DNS sync failed: {e}")
                        logger.warning(f"DNS sync failed: {e}")
            else:
                click.echo(f"Error: Generated configuration is invalid: {message}")
                sys.exit(1)
                
    except Exception as e:
        click.echo(f"Error: {e}")
        logger.exception("Generation failed")
        sys.exit(1)


@cli.command()
@click.option('--output', '-o', type=click.Path(), help='Output file (default: sites-config.yaml)')
@click.option('--dry-run', is_flag=True, help='Show configuration without writing file')
@click.pass_context
def migrate(ctx, output: Optional[str], dry_run: bool):
    """Import existing nginx configurations to YAML format"""
    config_file = ctx.obj['config_file']
    
    # Check if sites directory exists
    if not SITES_AVAILABLE.exists():
        click.echo(f"Error: {SITES_AVAILABLE} does not exist")
        sys.exit(1)
    
    # Set output file
    if output:
        output_file = Path(output)
    else:
        output_file = config_file
    
    try:
        # Initialize migrator
        migrator = NginxMigrator(SITES_AVAILABLE)
        
        # Migrate all sites
        click.echo(f"Scanning {SITES_AVAILABLE} for nginx configurations...")
        config_dict = migrator.migrate_all()
        
        if not config_dict.get('sites'):
            click.echo("No nginx configurations found to migrate")
            return
        
        # Generate YAML
        yaml_content = yaml.dump(config_dict, default_flow_style=False, sort_keys=False)
        
        if dry_run:
            click.echo("Migration preview:")
            click.echo("="*60)
            click.echo(yaml_content)
        else:
            # Write configuration file
            output_file.write_text(yaml_content)
            click.echo(f"Migration complete! Configuration written to {output_file}")
            click.echo(f"Found {len(config_dict['sites'])} sites")
            
            # Show summary
            for domain, config in config_dict['sites'].items():
                status = "enabled" if config.get('enabled', True) else "disabled"
                if 'upstreams' in config:
                    upstream_count = len(config['upstreams'])
                    click.echo(f"  {domain}: {upstream_count} upstream(s) - {status}")
                elif 'root' in config:
                    click.echo(f"  {domain}: static site - {status}")
                else:
                    click.echo(f"  {domain}: unknown type - {status}")
        
    except Exception as e:
        click.echo(f"Error: {e}")
        logger.exception("Migration failed")
        sys.exit(1)


@cli.command()
@click.argument('domain')
@click.option('--email', '-e', help='Email address for certificate registration')
@click.option('--dry-run', is_flag=True, help='Test certificate request without issuing')
@click.pass_context
def ssl(ctx, domain: str, email: Optional[str], dry_run: bool):
    """Request SSL certificate for domain"""
    # Check permissions first (unless dry-run)
    if not dry_run:
        try:
            require_sudo_privileges()
        except SystemExit:
            return
    
    try:
        # Load configuration to check include_www setting
        config_path = Path('sites-config.yaml')
        include_www = False
        
        if config_path.exists():
            try:
                parser = ConfigParser(config_path)
                site_config = parser.get_site(domain)
                if site_config:
                    include_www = site_config.get('include_www', False)
            except Exception as e:
                click.echo(f"Warning: Could not read configuration: {e}")
                click.echo("Proceeding without www subdomain...")
        
        certbot = CertbotManager(dry_run=dry_run)
        
        click.echo(f"Requesting SSL certificate for {domain}...")
        if include_www:
            click.echo(f"Including www.{domain} subdomain based on configuration")
        success, message = certbot.request_certificate(domain, email, include_www)
        
        if success:
            if dry_run:
                click.echo(f"Dry run successful for {domain}")
            else:
                click.echo(f"Certificate obtained successfully for {domain}")
                click.echo("Note: Run 'nginx-sites generate' to update configurations with SSL")
        else:
            click.echo(f"Certificate request failed: {message}")
            sys.exit(1)
            
    except Exception as e:
        click.echo(f"Error: {e}")
        logger.exception("SSL certificate request failed")
        sys.exit(1)


@cli.group()
def backup():
    """Backup and restore nginx configurations"""
    pass


@backup.command('create')
@click.option('--description', '-d', help='Description for the backup')
@click.pass_context
def backup_create(ctx, description: str):
    """Create a backup of current nginx configuration"""
    try:
        require_sudo_privileges()
    except SystemExit:
        return
    
    try:
        backup_manager = BackupManager(BACKUP_DIR)
        backup_path = backup_manager.create_backup(description or "manual")
        
        click.echo(f"Backup created: {backup_path.name}")
        
        # Show backup info
        info = backup_manager.get_backup_info(backup_path)
        click.echo(f"Size: {info['size']:,} bytes")
        click.echo(f"Contents: {len(info['contents'])} items")
        
    except Exception as e:
        click.echo(f"Error creating backup: {e}")
        logger.exception("Backup creation failed")
        sys.exit(1)


@backup.command('list')
def backup_list():
    """List available backups"""
    try:
        backup_manager = BackupManager(BACKUP_DIR)
        backups = backup_manager.list_backups()
        
        if not backups:
            click.echo("No backups found")
            return
        
        click.echo(f"Found {len(backups)} backup(s):")
        click.echo()
        
        for backup_path in backups:
            try:
                info = backup_manager.get_backup_info(backup_path)
                created = info['created'].strftime('%Y-%m-%d %H:%M:%S')
                size_mb = info['size'] / (1024 * 1024)
                desc = f" ({info['description']})" if info['description'] else ""
                
                click.echo(f"{backup_path.name}{desc}")
                click.echo(f"  Created: {created}")
                click.echo(f"  Size: {size_mb:.1f} MB")
                click.echo()
                
            except Exception as e:
                click.echo(f"{backup_path.name}: Error reading backup info: {e}")
        
    except Exception as e:
        click.echo(f"Error listing backups: {e}")
        sys.exit(1)


@backup.command('restore')
@click.argument('backup_name')
@click.option('--force', is_flag=True, help='Skip confirmation prompt')
@click.pass_context
def backup_restore(ctx, backup_name: str, force: bool):
    """Restore from a backup"""
    try:
        require_sudo_privileges()
    except SystemExit:
        return
    
    try:
        backup_manager = BackupManager(BACKUP_DIR)
        
        # Find backup file
        backup_path = BACKUP_DIR / backup_name
        if not backup_path.exists() and not backup_name.endswith('.tar.gz'):
            backup_path = BACKUP_DIR / f"{backup_name}.tar.gz"
        
        if not backup_path.exists():
            click.echo(f"Backup not found: {backup_name}")
            sys.exit(1)
        
        # Get backup info
        info = backup_manager.get_backup_info(backup_path)
        created = info['created'].strftime('%Y-%m-%d %H:%M:%S')
        
        click.echo(f"Restore from backup: {backup_path.name}")
        click.echo(f"Created: {created}")
        click.echo(f"Size: {info['size']:,} bytes")
        
        if not force:
            if not click.confirm("\nThis will replace current nginx configuration. Continue?"):
                click.echo("Restore cancelled")
                return
        
        # Restore backup
        success = backup_manager.restore_backup(backup_path)
        
        if success:
            click.echo("Backup restored successfully")
            
            # Validate and reload
            validator = NginxValidator()
            valid, message = validator.validate_config()
            
            if valid:
                success, reload_msg = validator.reload_nginx()
                if success:
                    click.echo("Nginx reloaded successfully")
                else:
                    click.echo(f"Warning: Failed to reload nginx: {reload_msg}")
            else:
                click.echo(f"Warning: Restored configuration has validation errors: {message}")
        else:
            click.echo("Restore failed")
            sys.exit(1)
            
    except Exception as e:
        click.echo(f"Error restoring backup: {e}")
        logger.exception("Backup restore failed")
        sys.exit(1)


@cli.command()
@click.option('--check-permissions', is_flag=True, help='Check system permissions')
@click.pass_context
def validate(ctx, check_permissions: bool):
    """Validate nginx configuration and system state"""
    config_file = ctx.obj['config_file']
    
    try:
        # Check system permissions if requested
        if check_permissions:
            click.echo("Checking system permissions...")
            valid, issues = validate_all_permissions()
            
            if valid:
                click.echo("✓ All permissions are valid")
            else:
                click.echo("✗ Permission issues found:")
                for issue in issues:
                    click.echo(f"  - {issue}")
                click.echo()
        
        # Validate YAML configuration if it exists
        if config_file.exists():
            click.echo("Validating YAML configuration...")
            parser = ConfigParser(config_file)
            
            errors = parser.validate_config()
            if errors:
                click.echo("✗ Configuration validation errors:")
                for error in errors:
                    click.echo(f"  - {error}")
                sys.exit(1)
            else:
                click.echo("✓ YAML configuration is valid")
                
                # Show summary
                sites = parser.get_enabled_sites()
                click.echo(f"✓ {len(sites)} enabled site(s) configured")
        else:
            click.echo(f"Configuration file not found: {config_file}")
        
        # Validate nginx configuration
        click.echo("Validating nginx configuration...")
        validator = NginxValidator()
        valid, message = validator.validate_config()
        
        if valid:
            click.echo("✓ Nginx configuration is valid")
        else:
            click.echo(f"✗ Nginx configuration errors: {message}")
            sys.exit(1)
            
    except Exception as e:
        click.echo(f"Error during validation: {e}")
        logger.exception("Validation failed")
        sys.exit(1)


@cli.command()
@click.option('--show-ssl', is_flag=True, help='Show SSL certificate information')
@click.pass_context
def status(ctx, show_ssl: bool):
    """Show current system status"""
    config_file = ctx.obj['config_file']
    
    try:
        # Show nginx status
        validator = NginxValidator()
        
        click.echo("Nginx Status:")
        version = validator.get_nginx_version()
        if version:
            click.echo(f"  Version: {version}")
        else:
            click.echo("  Version: Unknown")
        
        valid, message = validator.validate_config()
        click.echo(f"  Configuration: {'Valid' if valid else 'Invalid'}")
        
        # Show configuration status
        click.echo("\nConfiguration Status:")
        if config_file.exists():
            parser = ConfigParser(config_file)
            total_sites = len(parser.sites)
            enabled_sites = len(parser.get_enabled_sites())
            
            click.echo(f"  Configuration file: {config_file}")
            click.echo(f"  Total sites: {total_sites}")
            click.echo(f"  Enabled sites: {enabled_sites}")
            
            # Show site details
            if enabled_sites > 0:
                click.echo("\nEnabled Sites:")
                for domain, config in parser.get_enabled_sites().items():
                    if 'upstreams' in config:
                        upstream_count = len(config['upstreams'])
                        click.echo(f"  {domain}: {upstream_count} upstream(s)")
                    elif 'root' in config:
                        click.echo(f"  {domain}: static site")
                    else:
                        click.echo(f"  {domain}: unknown type")
        else:
            click.echo(f"  Configuration file: Not found ({config_file})")
        
        # Show SSL certificate status if requested
        if show_ssl:
            click.echo("\nSSL Certificates:")
            certbot = CertbotManager()
            certificates = certbot.list_certificates()
            
            if certificates:
                for cert in certificates:
                    name = cert.get('name', 'Unknown')
                    domains = ', '.join(cert.get('domains', []))
                    expiry = cert.get('expiry', 'Unknown')
                    valid = cert.get('valid', False)
                    status_symbol = "✓" if valid else "✗"
                    
                    click.echo(f"  {status_symbol} {name}")
                    click.echo(f"    Domains: {domains}")
                    click.echo(f"    Expires: {expiry}")
            else:
                click.echo("  No SSL certificates found")
        
        # Show backup status
        click.echo("\nBackup Status:")
        backup_manager = BackupManager(BACKUP_DIR)
        backups = backup_manager.list_backups()
        
        if backups:
            latest = backup_manager.get_backup_info(backups[0])
            created = latest['created'].strftime('%Y-%m-%d %H:%M:%S')
            click.echo(f"  Total backups: {len(backups)}")
            click.echo(f"  Latest backup: {backups[0].name} ({created})")
        else:
            click.echo("  No backups found")
            
    except Exception as e:
        click.echo(f"Error getting status: {e}")
        logger.exception("Status check failed")
        sys.exit(1)


@cli.command()
@click.option('--dry-run', is_flag=True, help='Show what would be changed without making changes')
@click.option('--aws-profile', default='route53', help='AWS profile to use for Route 53')
@click.pass_context
def sync_dns(ctx, dry_run: bool, aws_profile: str):
    """Sync DNS records with enabled sites"""
    config_file = ctx.obj['config_file']
    
    if not config_file.exists():
        click.echo(f"Error: Configuration file not found: {config_file}")
        click.echo("Run 'nginx-sites migrate' to create an initial configuration")
        sys.exit(1)
    
    try:
        # Parse configuration to get enabled domains
        parser = ConfigParser(config_file)
        enabled_sites = parser.get_enabled_sites()
        enabled_domains = [
            domain for domain in enabled_sites.keys()
            if domain.endswith('.jakekausler.com') or domain == 'jakekausler.com'
        ]
        
        if not enabled_domains:
            click.echo("No jakekausler.com domains found in configuration")
            return
        
        # Initialize Route 53 manager
        route53 = Route53Manager(profile_name=aws_profile)
        
        if dry_run:
            current_records = route53.get_existing_records()
            main_ip = route53.get_main_domain_ip()
            
            click.echo(f"Main domain IP: {main_ip}")
            click.echo(f"Enabled subdomains: {len([d for d in enabled_domains if d != 'jakekausler.com'])}")
            click.echo("\nCurrent A records:")
            for domain, ip in current_records.items():
                click.echo(f"  {domain} → {ip}")
            
            click.echo("\nWould create records for:")
            for domain in enabled_domains:
                if domain not in current_records and domain != 'jakekausler.com':
                    click.echo(f"  {domain} → {main_ip}")
            
            click.echo("\nWould delete records for:")
            essential = {'jakekausler.com'}
            for domain in current_records:
                if (domain not in enabled_domains and 
                    domain not in essential and 
                    domain.endswith('.jakekausler.com')):
                    click.echo(f"  {domain}")
        else:
            created, deleted = route53.sync_dns_records(enabled_domains)
            click.echo(f"DNS sync complete: {created} created, {deleted} deleted")
        
    except Exception as e:
        click.echo(f"Error: DNS sync failed: {e}")
        logger.exception("DNS sync failed")
        sys.exit(1)


if __name__ == '__main__':
    cli()